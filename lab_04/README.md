
# Отчет по лабораторной работе №4
# Алгоритмы сортировки

**Дата:** 2025-10-16  
**Семестр:** 3 курс, 5 семестр  
**Группа:** ПИЖ-б-о-23-2(2) 
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Виктор Блинов Александрович

---

## Цель работы
Изучить и реализовать основные алгоритмы сортировки. Провести их теоретический и практический сравнительный анализ по временной и пространственной сложности. Исследовать влияние начальной упорядоченности данных на эффективность алгоритмов. Получить навыки эмпирического анализа производительности алгоритмов.

---

## Теоретическая часть
Рассмотрены пять основных алгоритмов сортировки:
- **Bubble Sort** — многократно проходит по массиву, сравнивая соседние элементы и меняя их местами при необходимости. Сложность O(n²).
- **Selection Sort** — находит минимальный элемент из неотсортированной части и ставит его в начало. Сложность O(n²).
- **Insertion Sort** — строит отсортированный массив, вставляя элементы по одному. Сложность O(n²), но эффективно работает на почти отсортированных данных.
- **Merge Sort** — рекурсивно делит массив на две части, сортирует и сливает. Сложность O(n log n), требует O(n) памяти.
- **Quick Sort** — выбирает опорный элемент, делит массив и рекурсивно сортирует части. Сложность O(n log n) в среднем, O(n²) в худшем.

---

## Практическая часть

### Выполненные задачи
- [x] Реализованы 5 алгоритмов сортировки в файле `sorts.py`.
- [x] Реализована генерация тестовых данных (`generate_data.py`).
- [x] Проведено измерение производительности (`performance_test.py`).
- [x] Построены графики результатов (`plot_results.py`).

---

### Ключевые фрагменты кода
```python
def bubble_sort(arr):
    a = arr.copy()
    n = len(a)
    for i in range(n):
        swapped = False
        for j in range(n - 1 - i):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                swapped = True
        if not swapped:
            break
    return a
```

---

## Результаты выполнения

### Пример работы программы
```bash
Array size = 100
Bubble    | random         = 0.00058 sec
Selection | random         = 0.00032 sec
Insertion | random         = 0.00034 sec
Merge     | random         = 0.00024 sec
Quick     | random         = 0.00019 sec
Bubble    | sorted         = 0.00001 sec
Selection | sorted         = 0.00030 sec
Insertion | sorted         = 0.00004 sec
Merge     | sorted         = 0.00016 sec
Quick     | sorted         = 0.00016 sec
Bubble    | reversed       = 0.00090 sec
Selection | reversed       = 0.00041 sec
Insertion | reversed       = 0.00093 sec
Merge     | reversed       = 0.00020 sec
Quick     | reversed       = 0.00014 sec
Bubble    | almost_sorted  = 0.00036 sec
Selection | almost_sorted  = 0.00030 sec
Insertion | almost_sorted  = 0.00005 sec
Merge     | almost_sorted  = 0.00020 sec
Quick     | almost_sorted  = 0.00017 sec
```

---

### Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12450H 2.00 GHz
Оперативная память: 16 GB DDR4
ОС: Windows 11 Pro
Python: 3.13.1
```

## Выводы
1. Быстрая и сортировка слиянием демонстрируют наилучшую производительность на больших объемах данных.
2. Сортировка вставками эффективна для небольших и почти отсортированных массивов.
3. Простые алгоритмы (пузырьком, выбором) удобны для обучения, но не подходят для больших массивов.

---

## Ответы на контрольные вопросы
1. **Какие алгоритмы сортировки имеют сложность O(n²) в худшем случае, а какие — O(n log n)?**  
   O(n²): Bubble, Selection, Insertion.  
   O(n log n): Merge, Quick.
2. **Почему сортировка вставками (Insertion Sort) эффективна для маленьких или почти отсортированных массивов?**  
   Потому что количество перестановок минимально, и внутренняя часть алгоритма выполняется быстро.
3. **В чем разница между устойчивой (stable) и неустойчивой (unstable) сортировкой? Приведите пример устойчивого и неустойчивого алгоритма.**  
   Устойчивая сохраняет относительный порядок равных элементов (пример — Merge Sort, Insertion Sort). Неустойчивая может менять их местами (Quick Sort, Selection Sort).
4. **Опишите принцип работы алгоритма быстрой сортировки (Quick Sort). Что такое "опорный элемент" и как его выбор влияет на производительность?**  
   Алгоритм выбирает pivot (опорный элемент), делит массив на элементы меньше и больше pivot и рекурсивно сортирует части.
5. **Сортировка слиянием (Merge Sort) гарантирует время O(n log n), но требует дополнительной памяти. В каких ситуациях этот алгоритм предпочтительнее быстрой сортировки?**  
   Когда важна стабильность и предсказуемое время работы, особенно при работе с большими данными на диске или при многопоточности.

---

## Приложения
[Исходный код] `sorts.py`, `generate_data.py`, `performance_test.py`, `plot_results.py`

![График 1] (plots/sort_compare_100.png)
![График 2] (plots/sort_compare_1000.png)
![График 3] (plots/sort_compare_5000.png)
