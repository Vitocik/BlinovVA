# Отчет по лабораторной работе №9
# Исследование алгоритмов динамического программирования

**Дата:** 2025-12-10
**Семестр:** 3 курс, 1 полугодие (5 семестр)
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Блинов Виктор Александрович

---

## Цель работы
Изучить и реализовать классические алгоритмы динамического программирования (ДП), сравнить их эффективность, провести экспериментальные исследования производительности и визуализировать процесс вычислений для малых входных данных.

---

## Теоретическая часть
В работе рассматриваются следующие алгоритмы, основанные на динамическом программировании:

- **Фибоначчи** (рекурсивный, мемоизация, bottom-up)
- **Задача о рюкзаке (0–1)**  
- **Дробный рюкзак**  
- **LCS**  
- **Расстояние Левенштейна**  
- **Размен монет**  
- **LIS**

---

## Практическая часть

### Выполненные задачи
- [x] Реализованы алгоритмы ДП  
- [x] Визуализация таблицы ДП  
- [x] Сравнение алгоритмов  


---

## Характеристики ПК для тестирования

```
Процессор: 12th Gen Intel(R) Core(TM) i5-12450H 2.00 GHz
Оперативная память: 16 GB DDR4
ОС: Windows 11 Pro
Python: 3.13.1
```

---

## Ключевые фрагменты кода

```python
def fib_bottom_up(n: int) -> int:
    if n <= 1:
        return n
    prev, curr = 0, 1
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    return curr
```

```python
def knapsack_01(items: Sequence[Item], capacity: int):
    n = len(items)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        it = items[i - 1]
        for w in range(capacity + 1):
            dp[i][w] = dp[i - 1][w]
            if it.weight <= w:
                dp[i][w] = max(dp[i][w], dp[i - 1][w - it.weight] + it.value)

    w = capacity
    chosen = []
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i - 1][w]:
            chosen.append(items[i - 1])
            w -= items[i - 1].weight

    return dp[n][capacity], chosen[::-1]
```

---

## Результаты выполнения

```bash
=== ВИЗУАЛИЗАЦИЯ ===
Входные данные:
  it0: weight=6, value=5
  it1: weight=7, value=2
  it2: weight=2, value=18
  it3: weight=2, value=12
capacity = 10

--- после предмета i=1 (it0) ---
0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
0 | 0 | 0 | 0 | 0 | 0 | 5 | 5 | 5 | 5 | 5

--- после предмета i=2 (it1) ---
0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
0 | 0 | 0 | 0 | 0 | 0 | 5 | 5 | 5 | 5 | 5
0 | 0 | 0 | 0 | 0 | 0 | 5 | 5 | 5 | 5 | 5


=== Итоговая таблица ===
0 | 0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0
0 | 0 |  0 |  0 |  0 |  0 |  5 |  5 |  5 |  5 |  5
0 | 0 |  0 |  0 |  0 |  0 |  5 |  5 |  5 |  5 |  5
0 | 0 | 18 | 18 | 18 | 18 | 18 | 18 | 23 | 23 | 23
0 | 0 | 18 | 18 | 30 | 30 | 30 | 30 | 30 | 30 | 35
Оптимальная стоимость: 35
```

---

## Выводы
1. Bottom-up ДП работает быстрее и эффективнее по памяти.  
2. Мемоизация полезна, но уступает по производительности.  
3. Жадный алгоритм рюкзака быстрый, но не решает 0–1 задачу корректно.  

---

## Контрольные вопросы
1. **Какие два основных свойства задачи указывают на то, что для её решения можно применить динамическое программирование?** 
   - Оптимальная подструктура
    Оптимальное решение задачи можно построить из оптимальных решений её подзадач.
    Например: лучший выбор предметов для ёмкости W включает лучший выбор для меньшей ёмкости W − weight[i].

   - Перекрывающиеся подзадачи
    При рекурсивном разбиении одна и та же подзадача возникает многократно.
    Например: в рекурсивном вычислении Фибоначчи значения F(n−1) и F(n−2) используются десятки раз. 


2. **Разница между top-down и bottom-up?** 
   - Top-down: рекурсия + мемоизация, вычисляет только нужные подзадачи.
   - Bottom-up: итеративное заполнение таблицы, быстрее и без рекурсии.

3. **Как задача о рюкзаке 0–1 демонстрирует оптимальную подструктуру?**

- Оптимальное решение задачи для некоторой ёмкости строится из оптимальных решений подзадач для меньших ёмкостей: либо предмет не берётся, либо берётся, и тогда решение опирается на оптимальный выбор для оставшейся вместимости. Таким образом, большая задача раскладывается на несколько меньших оптимальных подзадач.

4. **Как строится таблица для LCS?**

- Строится матрица, где каждая ячейка отражает длину LCS для префиксов двух строк. Таблица заполняется последовательно: если текущие символы совпадают, значение увеличивается на единицу относительно диагонали; если нет — выбирается максимум из значений сверху или слева. В конце последняя ячейка содержит длину LCS.

5. **Как динамическое программирование уменьшает сложность вычисления Фибоначчи?**

- Вместо многократного перерасчёта одних и тех же значений сохраняются результаты промежуточных вычислений (мемоизация) либо последовательность строится снизу вверх. Это устраняет экспоненциальное дублирование вычислений и снижает сложность до линейной, а оптимизированный вариант с матрицами — до логарифмической.

---

## Приложения
- Файлы проекта:
  - `dynamic_programming.py`
  - `comparison.py`
  - `dp_experiments.py`
- Графики:
  - `knapsack_time_vs_n.png`
