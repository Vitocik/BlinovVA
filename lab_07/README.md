# Отчет по лабораторной работе №7
# Структура данных «Куча» и пирамидальная сортировка

**Дата:** 2025-11-15  
**Семестр:** 3 курс, 2 полугодие (6 семестр)  
**Группа:** ПИЖ-б-о-23-2(2)  
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** Блинов Виктор Александрович  

---

## Цель работы
Изучить структуру данных «куча», реализовать её основные операции и исследовать эффективность построения кучи и алгоритмов сортировки (Heapsort, QuickSort, MergeSort). Провести теоретический и практический сравнительный анализ, построить графики производительности и визуализировать структуру кучи.

---

## Теоретическая часть
Рассмотрены основные структуры и алгоритмы:

- **Min-heap / Max-heap** — полное бинарное дерево, удовлетворяющее свойству кучи:  
  Min-heap: родитель ≤ потомков  
  Max-heap: родитель ≥ потомков  

- **Операции кучи:**  
  `insert` — O(log n)  
  `extract` — O(log n)  
  `build_heap` — O(n)  
  `sift_up`, `sift_down` — восстановление свойства кучи  

- **Heapsort** — сортировка через max-heap, сложность O(n log n).

- **QuickSort** — рекурсивная сортировка, пивот — первый элемент,  
  средняя сложность O(n log n), худшая O(n²).

- **MergeSort** — сортировка слиянием, всегда O(n log n), требует O(n) памяти.

---

## Практическая часть

### Выполненные задачи
- [x] Реализована структура кучи (min и max)  
- [x] Реализованы операции вставки, удаления и построения кучи  
- [x] Реализован Heapsort (in-place)  
- [x] Реализованы QuickSort и MergeSort  
- [x] Написан модуль тестов (unittest)  
- [x] Выполнены замеры производительности  
- [x] Построены три графика результатов  
- [x] Визуализирована куча текстовым методом  

---

### Ключевые фрагменты кода

#### 1. Внутренний метод `_sift_down` (heap.py)
```python
def _sift_down(self, index: int) -> None:
    size = len(self.data)
    while True:
        left = 2 * index + 1
        right = 2 * index + 2
        candidate = index

        if left < size and self._compare(self.data[left], self.data[candidate]):
            candidate = left
        if right < size and self._compare(self.data[right], self.data[candidate]):
            candidate = right

        if candidate != index:
            self.data[index], self.data[candidate] = (
                self.data[candidate], self.data[index]
            )
            index = candidate
        else:
            break
```

#### 2. Метод `build_heap` (heap.py)
```python
def build_heap(self, array: List[Any]) -> None:
    """Построение кучи из массива за O(n)."""
    self.data = array[:]
    for i in range(len(self.data) // 2 - 1, -1, -1):
        self._sift_down(i)
```

#### 3. Вставка в кучу (`insert`) и извлечение (`extract`) (heap.py)
```python
def insert(self, value: Any) -> None:
    self.data.append(value)
    self._sift_up(len(self.data) - 1)

def extract(self) -> Optional[Any]:
    if not self.data:
        return None
    root = self.data[0]
    last = self.data.pop()
    if self.data:
        self.data[0] = last
        self._sift_down(0)
    return root
```

#### 4. In-place Heapsort (heapsort.py)
```python
def heapsort_inplace(array: List[Any]) -> None:
    def sift_down(a: List[Any], n_val: int, i: int) -> None:
        while True:
            left = 2 * i + 1
            right = 2 * i + 2
            largest = i
            if left < n_val and a[left] > a[largest]:
                largest = left
            if right < n_val and a[right] > a[largest]:
                largest = right
            if largest != i:
                a[i], a[largest] = a[largest], a[i]
                i = largest
            else:
                break

    n = len(array)
    for idx in range(n // 2 - 1, -1, -1):
        sift_down(array, n, idx)
    for end in range(n - 1, 0, -1):
        array[0], array[end] = array[end], array[0]
        sift_down(array, end, 0)
```

#### 5. Функция измерения времени (visualize.py)
```python
def measure(func: Callable[[], None]) -> float:
    start = time.perf_counter()
    func()
    return time.perf_counter() - start
```

---

## Результаты выполнения

### Пример работы программы
```bash
[BUILD] n=1000: insert=0.0003s, build_heap=0.0002s
[BUILD] n=2000: insert=0.0006s, build_heap=0.0004s
[SORT] n=4000: heapsort=0.0063s, sorted=0.0004s
[SORT] n=5000: heapsort=0.0076s, sorted=0.0005s
[COMPARE] n=1000: heap=0.0012s, quick=0.0009s, merge=0.0012s
[COMPARE] n=2000: heap=0.0029s, quick=0.0019s, merge=0.0023s

```

---

### Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12450H 2.00 GHz
Оперативная память: 16 GB DDR4
ОС: Windows 11 Pro
Python: 3.13.1
```

---

## Выводы
1. Построение кучи методом `build_heap` значительно эффективнее последовательной вставки.  
2. Heapsort демонстрирует предсказуемую производительность, но уступает встроенной сортировке Python.  
3. MergeSort показал высокую стабильность и близкую к Heapsort производительность на случайных данных.

---

## Ответы на контрольные вопросы

1. **Сформулируйте основное свойство min-кучи и max-кучи.**  
    - Min-heap — это такое бинарное дерево, в котором значение каждого родителя меньше или равно значениям его потомков. Корень min-кучи содержит минимальный элемент.

    - Max-heap — это бинарное дерево, в котором значение каждого родителя больше или равно значениям его потомков. Корень max-кучи содержит максимальный элемент.

2. **Опишите алгоритм вставки нового элемента в кучу (процедуру sift_up).**  
    Алгоритм вставки в кучу устроен следующим образом:
       1. Новый элемент добавляется в конец массива, представляющего собой полное бинарное дерево.
       2. Выполняется процедура sift_up: элемент сравнивается со своим родителем.
       3. Если нарушается свойство кучи (например, в min-heap элемент меньше родителя), элементы меняются местами.
       4. Процесс продолжается, пока либо элемент не окажется в корне, либо свойство кучи не будет восстановлено.
    Высота бинарного дерева логарифмическая, поэтому операция вставки работает за O(log n).

3. **Какова временная сложность построения кучи из произвольного массива и почему она равна O(n), а не O(n log n)?**  
    Хотя кажется, что нужно выполнить sift_down для каждого элемента массива, и каждая операция может занимать до O(log n), на практике построение кучи выполняется за O(n).
    Это происходит потому, что:
    - половина всех элементов массива — листья, и они не требуют вызова sift_down;
    - четверть — находятся на глубине 1;
    - дальше — всё меньше элементов на больших глубинах.
    Общая сумма всех затрат вычисляется как:
        (n/2)*0 + (n/4)*1 + (n/8)*2 + ... + 1*(log n)
    Эта сумма математически равна O(n). Поэтому алгоритм Флойда (build_heap) работает линейно.

4. **Опишите, как работает алгоритм пирамидальной сортировки (Heapsort).**  
    Алгоритм Heapsort состоит из двух этапов:
    1. Построение max-кучи из исходного массива — выполняется за O(n).
    2. Многократное извлечение максимального элемента:
       - Меняем местами первый (максимальный) элемент и последний.
       - Уменьшаем размер кучи на 1.
       - Вызываем sift_down(0), чтобы восстановить max-heap.
    Этот процесс повторяется, пока не будут обработаны все элементы.
    Итоговая сложность Heapsort — O(n log n).
    Сортировка выполняется in-place, не требуя дополнительной памяти (кроме O(1)).

 5. **Почему кучу часто используют для реализации приоритетной очереди? Какие операции приоритетной очереди она эффективно поддерживает?**
    Кучу используют для реализации приоритетной очереди, потому что она обеспечивает быстрый доступ к элементу с максимальным или минимальным приоритетом. Корень кучи всегда содержит элемент с наивысшим приоритетом.
    Куча эффективно поддерживает следующие операции:
    - insert(x) — вставка нового элемента, работает за O(log n);
    - extract_max() / extract_min() — извлечение элемента с максимальным/минимальным приоритетом, работает за O(log n);
    - peek() — получение элемента с высшим приоритетом без удаления, работает за O(1).
    Благодаря этим свойствам куча является оптимальной структурой данных для реализации приоритетных очередей.
