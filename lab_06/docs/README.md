# Отчет по лабораторной работе №6

# Бинарные деревья поиска (BST)

**Дата:** 2025-11-25
**Семестр:** 3 курс, 1 полугодие (5 семестр)
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Блинов Виктор Александрович

---

## Цель работы

Изучить древовидные структуры данных и их применение. Реализовать
бинарное дерево поиска (BST), освоить операции вставки, поиска,
удаления, научиться выполнять обходы дерева, визуализировать структуру и
провести экспериментальные измерения производительности.

---

## Теоретическая часть

-   Дерево - рекурсивная структура данных.
-   BST - левое поддерево содержит элементы меньше узла, правое - больше.
-   Операции: insert, search, delete.
-   Обходы: in-order, pre-order, post-order.
-   Сложность: O(log n) в среднем, O(n) в худшем.
-   Сбалансированные деревья предотвращают вырождение.

---

## Практическая часть

### Выполненные задачи

-   Реализован BinarySearchTree
-   Реализованы insert, search, delete
-   Обходы дерева (рекурсивные и итеративный)
-   Методы find_min, find_max, height, is_valid_bst
-   Текстовая визуализация
-   Эксперимент по производительности
-   Unit-тесты

---

## Ключевые фрагменты кода

``` python
def insert(self, value: int) -> None:
    if self.root is None:
        self.root = TreeNode(value)
        return

    current = self.root
    while True:
        if value < current.value:
            if current.left is None:
                current.left = TreeNode(value)
                return
            current = current.left
        elif value > current.value:
            if current.right is None:
                current.right = TreeNode(value)
                return
            current = current.right
        else:
            return
```

---

## Пример работы программы

``` bash
Tree visualization (indented):
50
  30
    20
    40
  70
    60
    80

Search 40 -> TreeNode(40)
Search 99 -> None
Is valid BST? True
Height: 3
```

---

## Характеристики ПК для тестирования
    ```
    Процессор: 12th Gen Intel(R) Core(TM) i5-12450H 2.00 GHz
    Оперативная память: 16 GB DDR4
    ОС: Windows 11 Pro
    Python: 3.13.1
    ```

---

## Выводы

1.  Реализована структура BST.
2.  Эксперимент подтвердил разницу между сбалансированным и вырожденным
    деревом.
3.  Самобалансирующиеся деревья предпочтительны в реальных задачах.

---

## Ответы на контрольные вопросы

1. **Сформулируйте основное свойство бинарного дерева поиска (BST).**
    Значения левого поддерева меньше значения узла, правого — больше.

2. **Опишите алгоритм вставки нового элемента в BST. Какова сложность этой операции в сбалансированном и вырожденном дереве?**
    Поиск подходящего места путём сравнения: если меньше — идём влево, если больше — вправо.
    Сложность:
    - O(log n) в сбалансированном дереве
    - O(n) в вырожденном

3. **Чем отличается обход дерева в глубину (DFS) от обхода в ширину (BFS)? Назовите виды DFS обходов и их особенности.**
    DFS — глубинный обход: pre-order, in-order, post-order.
    BFS — ширинный обход, использует очередь.

4. **Почему в вырожденном BST (например, когда элементы добавляются в отсортированном порядке) сложность операций поиска и вставки становится O(n)?**
    Потому что оно превращается в линейный список, высота дерева становится n.

5. **Что такое сбалансированное дерево (например, AVL-дерево) и как оно решает проблему вырождения BST?**
    Дерево, поддерживающее высоту около log₂(n), благодаря автоматической балансировке (Как в AVL или КЧ-деревьях).

---

## Приложения
- Исходный код
  - `binary_search_tree.py`
  - `tree_traversal.py`
  - `analysis.py`
  - `tests.py`
  - `main.py`
- График:
  - `bst_times.png`
