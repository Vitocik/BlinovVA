# Отчет по лабораторной работе №5  
# Хеш-функции и хеш-таблицы

**Дата:** 2025-11-10
**Семестр:** 3 курс, 1 полугодие (5 семестр)
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Блинов Виктор Александрович

---

## Цель работы
Изучить принципы работы хеш-функций и хеш-таблиц, методы разрешения коллизий  
(цепочки и открытая адресация), провести сравнительный анализ их эффективности,  
а также исследовать влияние коэффициента заполнения и качества хеш-функции  
на производительность таблиц.

---

## Теоретическая часть

**Хеш-функция** — это функция, которая преобразует произвольные данные  
в числовое значение фиксированного размера (хеш-код).  
Требования к хорошей хеш-функции:
- детерминированность (одинаковый вход → одинаковый хеш);
- равномерное распределение;
- высокая скорость вычисления;
- минимизация коллизий.

**Коллизия** — ситуация, когда два разных ключа дают одинаковое значение хеша.

**Методы разрешения коллизий:**
- **Метод цепочек (chaining):** в каждой ячейке хранится список элементов с одинаковым хешем;
- **Открытая адресация (open addressing):** все элементы хранятся в массиве,  
  при коллизии выполняется пробирование (линейное или двойное).

---

## Практическая часть

### Выполненные задачи
- [x] Реализованы три хеш-функции: simple, polynomial, djb2  
- [x] Реализована хеш-таблица с методом цепочек  
- [x] Реализована хеш-таблица с открытой адресацией (линейное и двойное пробирование)  
- [x] Написаны unit-тесты для проверки корректности работы  
- [x] Проведён эксперимент по производительности и построены графики  
- [x] Сохранены графики `collisions_hist.png`, `collisions.png`, `insertion_time.png`  
- [x] Проведён сравнительный анализ методов

---

### Ключевые фрагменты кода
```python
def djb2(s: str) -> int:
    """Хеш-функция DJB2 (Dan Bernstein)."""
    h = 5381
    for ch in s:
        h = (h * 33) + ord(ch)
    return h & 0x7FFFFFFF
```

```python
class ChainingHashTable:
    def insert(self, key: str, value: Any) -> None:
        idx = self._index(key)
        bucket = self._buckets[idx]
        if bucket:
            self.collisions += 1
        for i, (k, _) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        bucket.append((key, value))
        self._size += 1
```

---

## Результаты выполнения

### Пример работы программы
```bash
=== Измерения ===

Тест хеш-функции: simple_hash
Коэфф. заполнения | chaining (с) | linear (с) | double (с)
------------------------------------------------------------
    0.1              0.000021       0.000013       0.000016
    0.3              0.000033       0.000033       0.000037
    0.5              0.000046       0.000050       0.000056
    0.7              0.000065       0.000128       0.000138
    0.9              0.000326       0.000140       0.000172

Коллизии:
Метод цепочек: [0, 4, 9, 20, 41]
Линейное пробирование: [0, 7, 19, 85, 76]
Двойное хеширование: [0, 6, 16, 64, 54]

Тест хеш-функции: polynomial_hash
Коэфф. заполнения | chaining (с) | linear (с) | double (с)
------------------------------------------------------------
    0.1              0.000039       0.000024       0.000027
    0.3              0.000058       0.000058       0.000066
    0.5              0.000090       0.000097       0.000119
    0.7              0.000123       0.000223       0.000262
    0.9              0.000281       0.000264       0.000309

Коллизии:
Метод цепочек: [0, 4, 8, 21, 41]
Линейное пробирование: [0, 3, 27, 39, 92]
Двойное хеширование: [2, 9, 22, 54, 62]

Тест хеш-функции: djb2
Коэфф. заполнения | chaining (с) | linear (с) | double (с)
------------------------------------------------------------
    0.1              0.000038       0.000038       0.000017
    0.3              0.000063       0.000068       0.000042
    0.5              0.000424       0.000136       0.000070
    0.7              0.000152       0.000148       0.000160
    0.9              0.000300       0.000169       0.000194

Коллизии:
Метод цепочек: [0, 2, 8, 18, 39]
Линейное пробирование: [0, 9, 15, 50, 83]
Двойное хеширование: [0, 8, 31, 39, 58]
```

---

### Тестирование
- [x] Модульные тесты пройдены  
- [x] Производительность соответствует требованиям  

---

## Графики

### Время выполнения операций (`insertion_time.png`)
Отображает зависимость времени операций `insert`, `get`, `remove`
от коэффициента заполнения для всех комбинаций методов и хеш-функций.

### Количество коллизий (`collisions.png` и `collisions_hist.png`)
Показывает, как увеличивается число коллизий с ростом коэффициента загрузки.

---

### Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12450H 2.00 GHz
Оперативная память: 16 GB DDR4
ОС: Windows 11 Pro
Python: 3.13.1
```

---

## Выводы
1. Реализованы и протестированы три хеш-функции и три метода хеш-таблиц.  
2. Плохие хеш-функции (например, `simple`) вызывают лавинообразный рост коллизий,  
   особенно при линейном пробировании.  
3. Лучшие результаты по скорости и устойчивости к коллизиям показала  
   комбинация `djb2 + double hashing`.  
4. Оптимальный коэффициент заполнения — **до 0.7**; выше производительность падает.  

---

## Ответы на контрольные вопросы

1. **Каким требованиям должна удовлетворять хорошая хеш-функция?**  
   Детерминированность, равномерное распределение, высокая скорость вычисления,  
   минимальное количество коллизий.

2. **Что такое коллизия в хеш-таблице? Опишите два основных метода разрешения коллизий.**  
   Коллизия — совпадение хешей у разных ключей.  
   Основные методы:
   - Цепочки (chaining) — в одной ячейке хранится список элементов.
   - Открытая адресация (open addressing) — при коллизии ищется другая свободная ячейка (линейное, квадратичное или двойное пробирование).

3. **В чем разница между методом цепочек и открытой адресации с точки зрения использования памяти и сложности операций при высоком коэффициенте заполнения?**  
    - Цепочки используют списки внутри таблицы, проще реализуются и устойчивы к коллизиям.
    - Открытая адресация хранит все данные в массиве, экономит память, но хуже работает при высокой загрузке (α > 0.7).

4. **Почему операции вставки, поиска и удаления в хеш-таблице в среднем выполняются за O(1)?**  
   Потому что вычисление хеша и обращение по индексу происходят за постоянное время,а при равномерном распределении коллизии редки.

5. **Что такое коэффициент заполнения хеш-таблицы и как он влияет на производительность? Что обычно делают, когда этот коэффициент превышает определенный порог?**  
   Коэффициент заполнения (α = n/m) показывает, насколько таблица заполнена. При α > 0.7 резко растёт количество коллизий, поэтому таблицу увеличивают (rehash). Оптимальное значение — до 0.7.

---

## Приложения
- Исходный код:  
  - `hash_functions.py`  
  - `hash_table_chaining.py`  
  - `hash_table_open_addressing.py`  
  - `main.py`  
  - `test_hash_tables.py`
- Графики:  
  - `collisions.png`  
  - `collisions_hist.png`
  - `insertion_time.png`

