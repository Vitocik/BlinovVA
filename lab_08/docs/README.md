
# Отчет по лабораторной работе №8  
# Жадные алгоритмы

**Дата:** 2025-12-09  
**Семестр:** 3 курс, 5 семестр (1 полугодие)  
**Группа:** ПИЖ-б-о-23-2(2)  
**Дисциплина:** Анализ сложности алгоритмов 
**Студент:** Блинов Виктор Александрович

---

## Цель работы
Изучить метод проектирования жадных алгоритмов, понять свойства оптимальной подструктуры и жадного выбора, реализовать классические жадные алгоритмы, провести их анализ, сравнить их с точными методами и выполнить экспериментальное исследование времени работы алгоритма Хаффмана.

---

## Теоретическая часть

Жадные алгоритмы — это алгоритмы, которые строят решение по шагам, делая на каждом шаге выбор, который кажется наилучшим в данный момент.  
Метод работает, если выполняются два условия:

1. **Оптимальная подструктура** — оптимальное решение задачи содержит оптимальные решения подзадач.  
2. **Свойство жадного выбора** — можно выбрать часть оптимального решения, не рассматривая дальнейшие шаги.

Изучаемые алгоритмы:

- **Interval Scheduling** — выбор максимального числа непересекающихся интервалов.  
- **Fractional Knapsack** — оптимальное решение дробной задачи о рюкзаке.  
- **Huffman Coding** — построение оптимального префиксного кодирования.  
- **Greedy Coin Change** — размен монет жадным алгоритмом.  
- **Алгоритм Краскала** — построение минимального остовного дерева (MST).  

---

## Практическая часть

### Выполненные задачи
- [x] Реализован алгоритм выбора заявок  
- [x] Реализован дробный рюкзак  
- [x] Реализован алгоритм Хаффмана  
- [x] Реализован алгоритм размена монет  
- [x] Реализован алгоритм Краскала  
- [x] Добавлена теоретическая документация к каждому алгоритму  
- [x] Проведено сравнение жадного и точного алгоритма рюкзака  
- [x] Проведено экспериментальное исследование времени работы Хаффмана  
- [x] Создан график зависимости времени выполнения от размера входных данных  
- [x] Добавлен вывод результатов замеров в терминал  

---

## Характеристики ПК для тестирования
```
Процессор: 12th Gen Intel(R) Core(TM) i5-12450H 2.00 GHz
Оперативная память: 16 GB DDR4
ОС: Windows 11 Pro
Python: 3.13.1
```

---

## Ключевые фрагменты кода

### Алгоритм выбора заявок (Interval Scheduling)
```python
def interval_scheduling(intervals):
    sorted_intervals = sorted(intervals, key=lambda x: x[1])
    result = []
    last_end = None
    for start, end in sorted_intervals:
        if last_end is None or start >= last_end:
            result.append((start, end))
            last_end = end
    return result
```

### Дробный рюкзак
```python
def fractional_knapsack(items, capacity):
    indexed = []
    for i, (value, weight) in enumerate(items):
        indexed.append((i, value, weight, value / weight))
    indexed.sort(key=lambda x: x[3], reverse=True)
    result = []
    total = 0
    for i, v, w, r in indexed:
        if capacity <= 0:
            break
        if w <= capacity:
            result.append((i, 1.0))
            capacity -= w
            total += v
        else:
            fraction = capacity / w
            result.append((i, fraction))
            total += v * fraction
            capacity = 0
    return total, result
```

### Алгоритм Хаффмана
```python
class HuffmanNode:
    def __init__(self, freq, symbol=None, left=None, right=None):
        self.freq = freq
        self.symbol = symbol
        self.left = left
        self.right = right

def build_huffman_tree(frequencies):
    heap = [HuffmanNode(freq, sym) for sym, freq in frequencies.items()]
    heapq.heapify(heap)
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = HuffmanNode(left.freq + right.freq, None, left, right)
        heapq.heappush(heap, merged)
    return heap[0]
```

### Алгоритм Краскала
```python
def kruskal_mst(nodes, edges):
    ds = DisjointSet(nodes)
    result = []
    for w, u, v in sorted(edges):
        if ds.union(u, v):
            result.append((w, u, v))
    return result
```

---

## Результаты выполнения

### Вывод программы
```bash
=== Экспериментальное исследование времени работы Хаффмана ===
Размер    100 → время 0.000036 сек
Размер    500 → время 0.000024 сек
Размер   1000 → время 0.000021 сек
Размер   2000 → время 0.000021 сек
Размер   5000 → время 0.000022 сек
Размер  10000 → время 0.000023 сек

График сохранён в файл time_vs_size.png
```

### График времени работы
График демонстрирует почти линейный рост времени выполнения алгоритма Хаффмана.  
Файл графика: **time_vs_size.png**

---

## Тестирование

- [x] Алгоритмы корректно работают на тестовых примерах  
- [x] Визуализация построена  
- [x] Эксперименты показали ожидаемую асимптотику  
- [x] Производительность соответствует теории  

---

## Выводы

1. Жадные алгоритмы эффективны при наличии свойств оптимальной подструктуры и жадного выбора.  
2. Алгоритм Хаффмана демонстрирует оптимальность и хорошую масштабируемость.  
3. Точный алгоритм рюкзака 0–1 работает медленнее, что подтверждает преимущество жадных алгоритмов для больших данных.  

---

## Ответы на контрольные вопросы

1. **В чем заключается основная идея жадных алгоритмов?**  
   В локальном выборе максимально выгодного решения на каждом шаге.

2. **Почему стратегия выбора интервалов с минимальным временем окончания оптимальна?**  
   Потому что она оставляет максимальное количество времени для последующих интервалов (доказательство методом обмена).

3. **Пример задач, где жадный метод работает и не работает.**  
   ✔ Работает: Хаффман, Interval Scheduling, Fractional Knapsack.  
   ✘ Не работает: 0–1 Knapsack, нестандартные системы монет.

4. **Разница между дробным и дискретным рюкзаком.**  
   В дробном можно брать части предметов → жадный выбор оптимален.  
   В дискретном нельзя → жадность не работает.

5. **Оптимальность алгоритма Хаффмана.**  
   Он минимизирует суммарную стоимость кодов, всегда объединяя два наименее частотных элемента.

---

## Приложения
- Файлы проекта:
  - `greedy_algorithms.py`
  - `exact_algorithms.py`
  - `analysis.py`
  - `visualization.py`
- Графики:
  - `time_vs_size.png`
  - `huffman_tree.png`
